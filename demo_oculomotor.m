function demo_oculomotor(outfile, varargin)
    %render a demo showing the oculomotor dependence of global motion
    %integration in the presence of crowding. Right half shows Kitaoka's
    %optimized peripheral drift ilusion. Left side shows a global-local
    %stimulus with no global shift (i.e. all local)
    
    %how long to display captions for.
    
    n = 5;

    motion = CircularCauchyMotion();
    sprites = CauchySpritePlayer('process', motion);
    
    blank = FilledDisk('visible', 1);
    fixationBack = FilledDisk('visible', 1);
    fixation = FilledDisk('visible', 1);
    
    
    my_ = Genitive();
    
    persistent init__;
    this = autoobject...
            ( my_.n,                   5 ...  %two small locally opposed wheels
            , my_.motion.dt,           0.15 ...
            , my_.motion.radius,       1.5 ...
            , my_.motion.dphase,       0 ...
            , my_.motion.x,            repmat([-3], 1, 5) ...
            , my_.motion.y,            0 ...
            , my_.motion.color,        [0.5;0.5;0.5] ...
            , my_.motion.velocity,     repmat([-2.5], 1, 5) ... %velocity of peak spatial frequency
            , my_.motion.phase,        reshape(([1]*(1:5)/5-0.5)*2*pi, 1, []) ...
            , my_.motion.angle,        reshape(([1]*(1:5)/5)*360 + 90, 1, []) ...
            , my_.motion.wavelength,   1/3 ...
            , my_.motion.width,        0.25 ...
            , my_.motion.duration,     1/10 ...
            , my_.motion.order,        4 ...
            , my_.motion.t,            zeros(1, 5)...
            , my_.blank.loc,           [-5;0] ...
            , my_.blank.color,         127 ...
            , my_.blank.radius,        3 ...
            , my_.fixationBack.loc,    [   2 3 4 5;   0 0 0 0]...
            , my_.fixation.loc,        [-3 2 3 4 5; 0 0 0 0 0]...
            , my_.fixationBack.color,  [255, 0 0] ...
            , my_.fixation.color,      0 ...
            , my_.fixation.radius,     0.1 ...
            , my_.fixationBack.radius, 0.2 ...
            );
    
    if exist('outfile', 'var')
        playDemo(this, 'aviout', outfile, varargin{:});
    else
        playDemo(this, varargin{:});
    end
    
    function params = getParams() 
        params = struct...
        ( 'edfname',    '' ...
        , 'dummy',      1  ...
        , 'skipFrames', 0  ...
        , 'preferences', struct('skipSyncTests', 1, 'TextAntiAliasing', 1 ) ...
        , 'requireCalibration', 0 ...
        , 'hideCursor', 0 ...
        , 'aviout', '' ...
        , 'avistart', 2 ...
        , 'avirect', [0 0 640 320] ...
        , 'rect', [0 0 640 320]...
        , 'cal', Calibration('interval', 1/60, 'distance', 180/pi, 'spacing', [20/1024, 20/1024], 'rect', [0 0 640 320]) ...
        , 'priority', 0 ...
        );
    end
    
    function params = run(params)
        %how many frames to render
%        frames = makeLoop(params);

        %snakes = Sprites('images', {'rotsnake.png'}, 'loc', [0; 0], 'scale', 7.5/512, 'antialias', 1);
        
        trigger = Trigger();
        
        main = mainLoop...
            ( 'graphics', {blank, sprites, fixation}... %, occluder}...
            , 'input', {params.input.keyboard}...
            , 'triggers', {trigger}...
            );
        
        trigger.panic(keyIsDown('ESCAPE'), @main.stop);
        trigger.singleshot(atLeast('refresh', 0), @show);
        %trigger.singleshot(atLeast('refresh', 0), @shift);
        
        params = main.go(params);
        
        function show(k)
            sprites.setVisible(1, k.next);
            trigger.singleshot(atLeast('next', k.next + this.property__(my_.motion.dt) * 40 - 1/120), main.stop);
        end
        
        function shift(k)
            snakes.setLoc(randn(2,1)/100);
            trigger.singleshot(atLeast('next', k.next - log(rand()) * 0.1), @shift);
        end

    end
    
end