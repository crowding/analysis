function this = demo_carenv(outfile, varargin)
    %render a looping demo for Movie 1 of the paper
    %(diff between carrier and envelope motion)
    %based on ConcentricDemo with the adjustabiilty ripped out.
    n = 5;

    motion = CircularCauchyMotion();
    sprites = CauchySpritePlayer('process', motion);
    fixation = FilledDisk([-7.5 7.5;0 0], 0.2, 0, 'visible', 1);

    ambiguous_ = 1;
    color_ = 0;

    revsteps = 10;

    my_ = Genitive();

    persistent init__;
    this = autoobject...
            ( my_.n,                   1 ...  %two small locally opposed wheels
            , my_.motion.dt,           0.1 ...
            , my_.motion.radius,       500 ...
            , my_.motion.dphase,       .5 / 20 ...
            , my_.motion.x,            repmat([-5 5], 1, 5) ...
            , my_.motion.y,            5 ...
            , my_.motion.color,        [0.5;0.5;0.5]/2/sqrt(2) ...
              ... %velocity of peak spatial frequency
            , my_.motion.velocity,     repmat([-5 5], 1, 5) ...
            , my_.motion.phase,        reshape([1;1]*(1:5)*2*pi/5, 1, []) ...
            , my_.motion.angle,        reshape([1;1]*(1:5)*360/5 + 90, 1, []) ...
            , my_.motion.wavelength,   0.75 ...
            , my_.motion.width,        0.75 ...
            , my_.motion.duration,     2/30 ...
            , my_.motion.order,        4 ...
            , my_.motion.t,            zeros(1, 10)...
                , my_.fixation.loc, [-3.75 3.75; 0 0] ...
            );

    %twiddle things so it makes a loop...
    distribute();

    playDemo(this, 'aviout', outfile, varargin{:});

    function params = getParams()
        params = struct...
        ( 'edfname',    '' ...
        , 'dummy',      1  ...
        , 'skipFrames', 0  ...
        , 'preferences', struct('skipSyncTests', 1) ...
        , 'requireCalibration', 0 ...
        , 'hideCursor', 0 ...
        , 'aviout', '' ...
        , 'avistart', 3 ...
        , 'avirect', [0 0 640 256] ...
        , 'rect', [0 0 640 256]...
        , 'cal', Calibration...
          ( 'interval', 1/60, 'distance', 180/pi ...
          , 'spacing', [15/640, 15/640], 'rect', [0 0 640 256]) ...
        , 'priority', 0 ...
        );
    end

    function distribute()
    %make two wheels
        dp = 0.5 / motion.getRadius();
        da = dp*180/pi;
        [da, dp] = deal...
            ( [repmat(0, 1, n) repmat(da, 1, n)] ...
            , [repmat(0, 1, n) repmat(dp, 1, n)]);

        this.property__...
            ( my_.motion.x ...
              , [ repmat(fixation.property__(my_.loc(1,[1])), 1, n) ...
                  , repmat(fixation.property__(my_.loc(1,[2])), 1, n)] ...
              , my_.motion.y ...
              , [ (repmat(fixation.property__(my_.loc(2,1)), 1, n) ...
                   + motion.getRadius()) ...
                  (repmat(fixation.property__(my_.loc(2,2)), 1, n) ...
                                 + motion.getRadius())] ...
              , my_.motion.velocity ...  %velocity of peak spatial frequency
              , [-repmat(this.property__(my_.motion.velocity(1)), 1, n)...
                , repmat(this.property__(my_.motion.velocity(1)), 1, n)] ...
              , my_.motion.phase, repmat((1:n)*2*pi/n, 1, 2) - dp*revsteps/2 + pi/2 ...
              , my_.motion.dphase, dp ...
              , my_.motion.angle, repmat((1:n)*360/n, 1, 2) - da*revsteps/2 ...
              , my_.motion.t, zeros(1,2*n) ...
              );

        %both "ambiguous"
        this.property__...
            ( my_.motion.x, repmat(motion.getX(), 1, 2)...
            , my_.motion.y, repmat(motion.getY(), 1, 2)...
            , my_.motion.velocity...
              , reshape([motion.getVelocity(); motion.getVelocity()], 1, [])...
            , my_.motion.phase, repmat(motion.getPhase(), 1, 2) ...
            , my_.motion.dphase, repmat(motion.getDphase(), 1, 2) ...
            , my_.motion.phase, repmat(motion.getPhase(), 1, 2) ...
            , my_.motion.angle, repmat(motion.getAngle(), 1, 2) ...
            , my_.motion.t, repmat(motion.getT(), 1, 2)...
            );
        %but one not ambiguous
        this.property__...
            ( my_.motion.velocity((2*n+1):2:(4*n))...
              , -this.property__(my_.motion.velocity((2*n+1):2:(4*n)))...
            , my_.motion.dphase(1:2:(4*n)), 0 );
    end

    function params = run(params)
        %how many frames to render?
        ttd = transformToDegrees(params.cal);
        keyboardInput = params.input.keyboard;

        trigger = Trigger();
        keyboard = KeyDown();

        main = mainLoop ...
            ( 'graphics', {sprites} ...
            , 'triggers', {trigger, keyboard} ...
            , 'input', {keyboardInput} ...
            );

        trigger.singleshot(atLeast('refresh', 0), @start);
        keyboard.set(main.stop, 'ESCAPE');

        motion.reset();

        function start(h)
            sprites.setVisible(1, h.next);
            trigger.singleshot...
                ( atLeast('next', h.next + revsteps * motion.getDt()), @reverse );
            if ~isempty(outfile)
                trigger.singleshot( atLeast ...
                                      ( 'next' ...
                                      ,   h.next + params.cal.interval/2 ...
                                        + revsteps * motion.getDt() * 4) ...
                                  , main.stop)
            end
        end

        function reverse(k)
            motion.setPhase(pi - motion.getPhase());
            motion.setAngle( -motion.getAngle())
            motion.setVelocity( -motion.getVelocity() );
            motion.setDphase( -motion.getDphase() );
            sprites.setVisible(0);
            motion.reset();
            sprites.setVisible(1, k.next);
            trigger.singleshot...
                ( atLeast('next', k.next + revsteps * motion.getDt()), @reverse );
        end

        params = main.go(params);
    end
end