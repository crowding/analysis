?showMethods("simulate")
showMethods("simulate")
?mer
simulate.ANY
?getMethod
getMethod("simulate", "lm")
getMethod("simulate", "glm")
ls()
simulate(individual.fit.optim, 10)
?simulate
simulate(individual.fit.optim)
individual.fit.optim
simple.fit
class(simple.fit)
simulate(simple.fit,2)
class(individual.fit.optim)
sim.glm
sim(simple.fit,2)
rm(simulate.glm.2asym)
sim
showMethods("sim")
?showMethods
test <- sim(simple.fit,10)
class(test)
sim.glm
getMethod("sim", "glm")
test
?sim
invert(individual.fit.optim$hessian)
?inv
dim(individual.fit.optim$hessian)
?invert
RSiteSearch("invert")
library(Matrix)
?invert
invert
?svd
solve(individual.fit.optim$hessian)
solve(individual.fit.optim$hessian)
?solve
detach(Matrix)
detach("Matrix")
?library
library
summary(scaling.fit.optim, correlation=TRUE, dispersion=scaling.fit.optim$dispersion)
summ <- summary(scaling.fit.optim, correlation=TRUE, dispersion=scaling.fit.optim$dispersion)
summ$corr
summ$df
?summary.glm
dim(summ$corr)
k <- 12
summ$coef
?diag
diag(V.test)
diag(V.beta)
sd.beta
sd.beta
diag(V.beta)
diag(V.test)
diag(V.test)
par
diag(V.test) / diag(V.beta)
?mvrnorm
solve(V.beta)
diag(solve(V.beta))
diag(scaling.fit.optim$hessian)
rbind(diag(scaling.fit.optim$hessian), diag(solve(V.beta)))
rbind(diag(scaling.fit.optim$hessian)[(j+1):(j+k)], diag(solve(V.beta)))
j
k
scaling.fit$optim$par
scaling.fit.optim$par
scaling.fit.optim$par$par
rbind(diag(V.beta), diag(V.test))
?registerMethod
apropos("method")
?registerS3method
?setMethod
getMethod("sim", "glm")
A
debugger()
4
B
3
B
Q
A(3, 1, -1, -1, 1, 0)
A(4, 1, -1, -1, 1, 0)
A(5, 1, -1, -1, 1, 0)
A(6, 1, -1, -1, 1, 0)
A(7, 1, -1, -1, 1, 0)
A(8, 1, -1, -1, 1, 0)
A(9, 1, -1, -1, 1, 0)
A(10, 1, -1, -1, 1, 0)
getOptions("expressions")
getOption("expressions")
options(expressions=10000)
A(10, 1, -1, -1, 1, 0)
for (k in 0:10) A(k, 1, -1, -1, 1, 0)
for (k in 0:10) print(A(k, 1, -1, -1, 1, 0))
for (k in 0:10) print(A(k, 1, -1, -1, 1, 0))
for (k in 0:10) print(A(k, 1, -1, -1, 1, 0))
for (k in 0:10) print(A(k, 1, -1, -1, 1, 0))
?call
(function(x) substitute(x+x))(123
)
call.by.name(x1, x2, x3, x4, "foo")
call.by.name(x1, x2, x3, x4, "foo")
call.by.name(x1, x2, x3, x4, "foo")
call.by.name(x1, x2, x3, x4, "foo")
call.by.name(x1, x2, x3, x4, "foo")
call.by.name(x1, x2, x3, x4, "foo")
call.by.name(x1, x2, x3, x4, "foo")
call.by.name(x1, x2, x3, x4, "foo")
call.by.name(x1, x2, x3, x4, "foo")
call.by.name(x1, x2, x3, x4, "foo")
enquote(list(1,2,3,4))
a <- list(1,2,3,4)
enquote(a)
call.by.name(x1, x2, x3, x4, "foo")
call.by.name(x1, x2, x3, x4, "foo")
call.by.name(x1,x2,x3,x4,x5, {
  Aout <- NULL
  B <- function() {
    k <<- k - 1
    Bout <- Aout <<- A(k, B(), x1, x2, x3, x4)
  }
  if (k <= 0) Aout <- x4 + x5 else B()
  Aout
})
for (k in 0:10) print(A(k, 1, -1, -1, 1, 0))
call.by.name(x1, x2, x1+x2)
call.by.name(x1, x2, x1+x2)
call.by.name(x1, x2, x1+x2)
cl
cl[length(cl)]
class(cl[length(cl)])
cl[length(cl)][[1]]
cl[length(cl)][[2]]
cl <- as.list(match.call)
cl
cl <- as.list(match.call())
cl
call.by.name(x1, x2, x1+x2)
call.by.name(x1, x2, x1+x2)
A(1, 1, -1, -1, 1, 0)
A(1, 1, -1, -1, 1, 0)
A(1, 1, -1, -1, 1, 0)
n
n
n
n
sublist
do.call("call", c("list", sublist))
Q
A(1, 1, -1, -1, 1, 0)
A(1, 1, -1, -1, 1, 0)
expr
Q
A(1, 1, -1, -1, 1, 0)
expr
A(1, 1, -1, -1, 1, 0)
sublist
subcall
enquote(sublist)
eval(enquote(sublist))
enquote(sublist)
quote(5)
lapply(enquote, sublist)
lapply(sublist, enquote)
subcall
Q
A(1, 1, -1, -1, 1, 0)
A(1, 1, -1, -1, 1, 0)
A(1, 1, -1, -1, 1, 0)
recover()
options(error=recover)
A(1, 1, -1, -1, 1, 0)
10
expr
0
options(error=
)
0
A(1, 1, -1, -1, 1, 0)
expr
.caller
evalq(1, .caller)
c
expr
.caller
options(error=)
0
options(error=NULL)
expr
evalq(evalq(-1, .caller), .caller)
evalq(evalq(-1), .caller)
.caller
ls(.caller)
?parent.frame
ls(parent.frame(2))
ls(parent.frame(1))
ls(parent.frame(0))
ls(parent.frame(-1))
A(1, 1, -1, -1, 1, 0)
c
expr
parent.frame(-1)
parent.frame(1)
parent.frame(2)
ls(parent.frame(2))
ls(parent.frame(1))
ls(parent.frame(3))
ls(parent.frame(4))
ls(parent.frame(5))
ls()
.caller
0
Q
A(1, 1, -1, -1, 1, 0)
.caller
ls(.caller)
ls(parent.frame())
ls(parent.frame(2))
ls(parent.frame(3))
ls(parent.frame(4))
parent.frame(4)
parent.frame(3)
parent.frame(2)
parent.frame(1)
.caller
Q
A(1, 1, -1, -1, 1, 0)
.caller
ls(.caller)
c
ls(.caller)
Q
A(1, 1, -1, -1, 1, 0)
A(4, 1, -1, -1, 1, 0)
A(2, 1, -1, -1, 1, 0)
options(expressions=100000)
A(4, 1, -1, -1, 1, 0)
length(quote(function(x, y, z) {x, y, z}) )
length(quote(function(x, y, z) {x + y + z}) )
quote(function(x, y, z) {x + y + z})[[1]]
quote(function(x, y, z) {x + y + z})[[2]]
quote(function(x, y, z) {x + y + z})[[3]]
quote(function(x, y, z) {x + y + z})[[4]]
?print
n
n
n
n
n
subcall
n
fndef[[3]]
n
fndef[[3]]
n
A
print(A, useSource=FALSE)
A(4, 1, -1, -1, 1, 0)
c
c
c
c
c
c
c
.expr
Q
Q
A
print(a, useSource=FALSE)
print(A, useSource=FALSE)
options(expressions=10000)

for (k in 0:10) print(A(k, 1, -1, -1, 1, 0))
sapply(0:10, A, 1, -1, -1, 1, 0)
mapply(A, 0:10, 1, -1, -1, 1, 0)
?sscanf
?scan
sum(scan("", numeric(0), 2))
13487 12345987
sum(scan("", numeric(0), 2))
aqsdfkjh 3489 23hjh 347
upper.tri(1:12 %o% 1:12, diag = TRUE)
upper.tri(1:12 %o% 1:12, diag = TRUE) * 1:12 %o% 1:12
?corr
apropos("tri")
?triu
getClass(sim)
getClass("sim")
getMethod("sim", "glm")
debugger()
0
recover()
options(error=recover)
2
ls()
3
ls()
beta
dim(beta)
Q
3
n.sims
beta.hat
Q
3
V.beta
V.beta
object$hessian
dim(object$hessian)


3
length(object$coefficients)
0
Q
debug(sim.glm)
0
diag(object$hessian)
0
0
diag(individual.fit.optim$hessian)
psyfun.2asym
0
4
nearPD
iter
maxit
converged
Q
scaling.fit.optim$hessian
solve(scaling.fit.optim$hessian)
nearPD(solve(scaling.fit.optim$hessian))
0
any(is.na(solve(scaling.fit.optim$hessian)))
nearPD
any(is.na(solve(scaling.fit.optim$hessian)))
nearPD(solve(scaling.fit.optim$hessian))
1
conv
Y
X
Q
scaling.fit.optim$hessian
solve(scaling.fit.optim$hessian)
individual.fit.optim
10
par
match.call()
Q
3
par
2
ls()
3
ls()
1
ls()
link.2asym$familyfun$par()
9
substitute(par)
ls()
par
Q
joined.asymptote(asymptote.cases)
joined.asymptote(asymptote.cases)$par()
joined.asymptote(asymptote.cases)$familyfun()
0
joined.asymptote(asymptote.cases)$familyfun(considered.trials)
0
joined.asymptote(asymptote.cases)$familyfun(trials.considered)
0
joined.asymptote(asymptote.cases)$familyfun(trials.considered, joined.asymptote(asymptote.cases)$par())
debug(glm.2asym)
n
n
n
link.2asym$familyfun(model.frame(formula, data=data), link.2asym$familyfun$par())
0
link.2asym$familyfun$par()
0
Q
undebug(glm.2asym)
Q
undebug(glm.2asym)
undebug(model.frame.glm)
c
individual.fit.optim$par$par
scaling.fit.optim$par$par
  individual.fit.optim$hessian <- hessian(individual.fit.optim)
  scaling.fit.optim$hessian <- hessian(scaling.fit.optim)

0
save.image()
1 || 0
0 && "dsfargeg"
eigen(scaling.fit.optim$hessian)
RSiteSearch("definite")
eigen(individual.fit.optim$hessian)
eigen(-individual.fit.optim$hessian)
names(solve(scaling.fit.optim$hessian))
solve(scaling.fit.optim$hessian)
RSiteSearch("pseudoinverse")
0
3
solve(object$hessian)
nearPD(-object$hessian)
Q
individual.fit.optim$sim
save.image()
individual.fit.optim$sim
names(individual.fit.optim)
names(individual.fit.optim$sim)
slotNames(individual.fit.optim$sim)
adply
apropos("roots")
apropos("root")
?polyroot
predict.lm
family(individual.fit.optim)
0
sampledata
predict
coefs
n
n
0
n
n
n
0
type
newdata
?predict
?predict.glm
n
n
n
n
n
0
10
predict.glm
Q
0
options(error=dump.frames())
?adply
?create_progress_bar
colnames(individual.ensemble)
nrow(individual.ensemble)
subset(individual.ensemble, i==1)
plot.points
?str
?next
save.image()
?runif
scaling.ensemble
?aes
?interaction
?do.call
?list
substitute(list(i=1), list(i=quote(j)))
?structure
?data.frame
?rename
?rename
methods(individual.fit.optim)
methods(class=class(individual.fit.optim))
methods(class="glm")
model(individual.fit.optim)
model.frame(individual.fit.optim)
names(model.frame(individual.fit.optim))[[1]]
individual.fit.optim$x
individual.fit.optim$model
?model.frame.glm
model.frame.glm
traceback()
colnames(individual.ensemble)
individual.ensemble
plot.points
individual.ensemble
colnames(individual.ensemble)
out
colnames(out)
c
c
c
c
c
c
c
c
c
c
names(individual.ensemble)
unique(individual.ensemble$X1)
unique(individual.ensemble$sim)
?maply
adply
individual.ensemble
?adply
?aaply
names(individual.ensemble)
individual.ensemble
colnames(individual.ensemble)
as.data.frame(individual.ensemble)
